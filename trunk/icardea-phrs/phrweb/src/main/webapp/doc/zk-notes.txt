http://www.zkoss.org/javadoc/latest/zk/org/zkoss/zk/ui/util/Composer.html#
public interface Composer

Represents a composer to initialize a component (or a component of tree) when ZK loader is composing a component. It is the controller in the MVC pattern, while the component is the view.

To initialize a component, you can implement this interface and then specify the class or an instance of it with the apply attribute as follows.

<window apply="my.MyComposer"/>
<window apply="${a_composer}"/>

Then, ZK loader will

    Invoke ComposerExt.doBeforeCompose(org.zkoss.zk.ui.Page, org.zkoss.zk.ui.Component, org.zkoss.zk.ui.metainfo.ComponentInfo), if the composer also implements ComposerExt.
    Create the component (by use of UiFactory.newComponent(org.zkoss.zk.ui.Page, org.zkoss.zk.ui.Component, org.zkoss.zk.ui.metainfo.ComponentInfo), which creates and initializes the component accordingly).
    Invokes ComposerExt.doBeforeComposeChildren(org.zkoss.zk.ui.Component), if ComposerExt is also implemented.
    Composes all children, if any, of this component defined in the ZUML page.
    Invokes doAfterCompose(org.zkoss.zk.ui.Component) after all children are, if any, composed.
    Posts the onCreate event if necessary.

To intercept the lifecycle of the creation of a page, implement Initiator and specify the class with the init directive.

Note: AfterCompose has to be implemented as part of a component, while Composer is a controller used to initialize a component (that might or might not implement AfterCompose).



---------------------------------
http://www.zkoss.org/javadoc/latest/zk/org/zkoss/zk/ui/util/GenericForwardComposer.html#
An abstract composer that you can extend and write intuitive onXxx$myid event handler methods with auto event forwarding and "auto-wired" accessible variable objects such as embedded objects, components, and external resolvable variables in a ZK zuml page; this class will add forward condition to the myid source component and forward source onXxx event received by the source myid component to the target onXxx$myid event (as defined in this composer) of the supervised target component; of course it will also registers onXxx$myid events to the supervised component and wire all accessible variable objects to this composer by calling setXxx() method or set xxx field value directly per the variable name.

Notice that since this composer kept references to the components, single instance object cannot be shared by multiple components.

The following is an example. The onChange event received by Textbox mytextbox will be forwarded to target Window mywin as a new target event onChange$mytextbox and the Textbox component with id name "mytextbox" and Label with id name mylabel are injected into the "mytextbox" and "mylabel" fields respectively(so you can use mytextbox and mylabel variable directly in onChange_mytextbox without problem).


 MyComposer.java
 
 public class MyComposer extends GenericForwardComposer {
     private Textbox mytextbox;
     private Window self; //embeded object, the supervised window "mywin"
     private Page page; //the ZK zuml page
     private Label mylabel;
     
     public void onChange$mytextbox(Event event) {
         mylabel.setValue("You just entered: "+ mytextbox.getValue());
     }
 }
 
 test.zul
 
 <window id="mywin" apply="MyComposer">
     <textbox id="mytextbox"/>
     <label id="mylabel"/>
 </window>
 ----
 -----
 -----
 Writing The ZK Application

    There are really only two things to keep in mind when using ZK inside of Liferay. The first, Liferay abstracts ZK to a certain extent, so you MUST use a bounding Window to be the base of all of your portlets. This will ensure that components will not have a namespace clash. I usually use something like this:

<window border="none" mode="embedded"/>


It will not even show up as visible, but it is enough to prevent two ZK portlets on the same page from interfering with each other.

    The second thing to remember is that you cannot use

execution.sendRedirect()

. If you need to load a second ZUL page, use

Executions.createComponents()

and replace the existing components with your new components. If you try to redirect the user to another ZUL page, it will redirecto to a non-existant generated URL.

    Liferay implements several features designed to speed up application processing and serving content. For most applications these features work very well, but in the case of the dynamically generated JavaScript from ZK, this all causes problems with how the ZK applications. 
    I found THIS article from the ZK forum which helped me http://www.zkoss.org/forum/listComment/6966/
    . You create a new properties file which you name liferay-plugin-package.properties 
    and in the file put a line which reads:


speed-filters-enabled=false


Save that file in your WEB-INF for your new portlet WAR file and you are good to go!
 
 